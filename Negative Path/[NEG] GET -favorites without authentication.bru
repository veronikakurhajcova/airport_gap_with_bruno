meta {
  name: [NEG] GET /favorites without authentication
  type: http
  seq: 2
}

get {
  url: {{baseUrl}}/favorites
  body: none
  auth: inherit
}

tests {
  // Test configuration constants
  const endpoint = '/favourites';
  const MAX_RESPONSE_TIME = 1000;
  const requiredErrorKeys = ["status", "title", "detail"];
  const EXPECTED_ERROR_MSG = "You are not authorized to perform the requested action.";
  
  // Extract response data for testing
  const body = res.getBody();
  const errors = body.errors;
  const contentType = res.getHeader("content-type");
  
  // Verify HTTP status code
  test("[NEG] - Status Code - should return 401 - " + endpoint, () => {
    expect(res.getStatus(), `Status code should be 401 but got ${res.getStatus()}`).to.eql(401);
  });
  
  // Verify response time meets performance requirements
  test("[NEG] - Performance - should respond within acceptable time - " + endpoint, () => {
    expect(res.getResponseTime(), `Response time ${res.getResponseTime()}ms exceeded limit of ${MAX_RESPONSE_TIME}ms`).to.be.below(MAX_RESPONSE_TIME);
  });
  
  // Verify response returns correct content type header
  test("[NEG] - Headers - should return JSON content type - " + endpoint, () => {
    expect(contentType, `Expected Content-Type to include "application/json" but got "${contentType}"`).to.include("application/json");
  });
  
  // Verify response body contains errors property
  test("[NEG] - Response Structure - should have errors property - " + endpoint, () => {
    expect(body, "Response body should have 'errors' property").to.have.property('errors');
  });
  
  // Verify errors is an array
  test("[NEG] - Response Structure - should return errors array - " + endpoint, () => {
    expect(errors, `Expected errors to be an array but got ${typeof errors}`).to.be.an('array');
  });
  
  // Verify errors array is not empty
  test("[NEG] - Response Structure - errors array should not be empty - " + endpoint, () => {
    expect(errors.length, "Errors array should contain at least one error").to.be.greaterThan(0);
  });
  
  // Verify error object contains all required keys
  test("[NEG] - Error Structure - should have all required keys - " + endpoint, () => {
    requiredErrorKeys.forEach(key => {
      expect(errors[0], `Error object is missing required key: "${key}"`).to.have.property(key);
    });
  });
  
  // Verify all error fields are of string type
  test("[NEG] - Schema Validation - all error fields should be strings - " + endpoint, () => {
    expect(errors[0].status, `Field "status" should be a string`).to.be.a('string');
    expect(errors[0].title, `Field "title" should be a string`).to.be.a('string');
    expect(errors[0].detail, `Field "detail" should be a string`).to.be.a('string');
  });
  
  // Verify error fields are not empty strings
  test("[NEG] - Schema Validation - error fields should not be empty - " + endpoint, () => {
    expect(errors[0].status.length, `Field "status" should not be empty`).to.be.greaterThan(0);
    expect(errors[0].title.length, `Field "title" should not be empty`).to.be.greaterThan(0);
    expect(errors[0].detail.length, `Field "detail" should not be empty`).to.be.greaterThan(0);
  });
  
  // Verify error status code matches expected value
  test("[NEG] - Error Validation - should return correct error status - " + endpoint, () => {
    expect(errors[0].status, `Expected error status to be "401" but got "${errors[0].status}"`).to.eql("401");
  });
  
  // Verify error detail message contains expected text
  test("[NEG] - Error Validation - should include error message - " + endpoint, () => {
    expect(errors[0].detail, `Expected error detail to include "${EXPECTED_ERROR_MSG}" but got "${errors[0].detail}"`).to.include(EXPECTED_ERROR_MSG);
  });
}

settings {
  encodeUrl: true
  timeout: 0
}
