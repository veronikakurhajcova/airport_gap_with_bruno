meta {
  name: [HP] GET /favorites/:id
  type: http
  seq: 5
}

get {
  url: {{baseUrl}}/favorites/{{fid}}
  body: none
  auth: inherit
}

headers {
  Authorization: Bearer token={{airportgap_token}}
}

vars:pre-request {
  id: 22
}

tests {
  const body = res.getBody();
  const data = body.data;
  const attributes = data.attributes;
  const airportData = attributes.airport;
  const note = attributes.note;
  const timezone = airportData.timezone;
  const endpoint = '/favorites/:id';
  
  // Configuration
  const MAX_RESPONSE_TIME_MS = 2000;
  
  // Validation schema
  const schema = {
    type: "object",
    required: ["id", "type", "attributes"],
    properties: {
      id: { type: "string" },
      type: { type: "string" }, 
      attributes: {
        type: "object",
        required: ["airport", "note"],
        properties: {
          airport: {
            type: "object",
            required: ["id", "name", "city", "country", "iata", "icao", "latitude", "longitude", "altitude", "timezone"],
            properties: {
              id: { type: "number" },
              name: { type: "string" },
              city: { type: "string" },
              country: { type: "string" },
              iata: { type: "string" },
              icao: { type: "string" },
              latitude: { type: "string" },
              longitude: { type: "string" },
              altitude: { type: "number" },
              timezone: { type: "string" }
            }
          },
          note: { type: "string" }
        }
      }
    }
  };
  
  // Helper function
  function validateAirportIATAFormat(airportData, airportName) {
    expect(airportData.iata, `${airportName} IATA code "${airportData.iata}" does not match format (3 uppercase letters)`).to.match(/^[A-Z]{3}$/);
  }
  
  // Test 1: Status code
  test("[HP] - Status Code - should return 200 - " + endpoint, () => {
    expect(res.getStatus(), `Expected status code 200 but got ${res.getStatus()}`).to.equal(200);
  });
  
  // Test 2: Response time
  test("[HP] - Performance - should respond within acceptable time - " + endpoint, () => {
    expect(res.getResponseTime(), `Response time ${res.getResponseTime()}ms exceeded ${MAX_RESPONSE_TIME_MS}ms`).to.be.below(MAX_RESPONSE_TIME_MS);
  });
  
  // Test 3: Content-Type
  test("[HP] - Headers - should return JSON content type - " + endpoint, () => {
    const contentType = res.getHeader('content-type');
    expect(contentType, `Expected Content-Type to include "application/json" but got "${contentType}"`).to.include('application/json');
  });
  
  // Test 4: Base structure
  test("[HP] - Response Structure - should return data object - " + endpoint, () => {
    expect(body, `Response body is missing "data" property`).to.have.property('data');
    expect(data, `Property "data" should be object but got ${typeof data}`).to.be.an('object');
    expect(data, `Data should not be an array for single favorite endpoint`).to.not.be.an('array');
  });
  
  // Test 5: Data object not empty
  test("[HP] - Data Validation - data object should not be empty - " + endpoint, () => {
    expect(Object.keys(data).length, `Data object is empty`).to.be.greaterThan(0);
  });
  
  // Test 6: ID validation - favorite ID should match request
  test("[HP] - ID Validation - favorite ID should match request ID - " + endpoint, () => {
    const requestedId = bru.getEnvVar("fid");
    expect(data.id, `Request favorite id "${requestedId}" doesn't match response id "${data.id}"`).to.equal(String(requestedId));
  });
  
  // Test 7: Schema Validation & Data Type Validation
  test("[HP] - Contract Testing - Schema Validation", () => {
    // 1. Root data properties
    schema.required.forEach(key => {
      expect(data, `Data missing: ${key}`).to.have.property(key);
      expect(data[key], `Type mismatch for ${key}`).to.be.a(schema.properties[key].type);
    });
  
    // 2. Attributes properties
    const attrSchema = schema.properties.attributes;
    attrSchema.required.forEach(key => {
      expect(attributes, `Attributes missing: ${key}`).to.have.property(key);
    });
  
    // 3. Airport properties
    const airSchema = attrSchema.properties.airport;
    airSchema.required.forEach(key => {
      expect(airportData, `Airport detail missing: ${key}`).to.have.property(key);
      expect(airportData[key], `Type mismatch for ${key}`).to.be.a(airSchema.properties[key].type);
    });
  });
  
  // Test 8: IATA format validation
  test("[HP] - Data Integrity - IATA code format - " + endpoint, () => {
    validateAirportIATAFormat(airportData, "Favorite Airport");
  });
  
  // Test 9: GPS coordinates validation
  test("[HP] - Range Validation - airports should have valid GPS coordinates - " + endpoint, () => {
    const lat = Number(airportData.latitude);
    const long = Number(airportData.longitude);
    expect(lat, `Airport latitude ${lat} is out of range (-90 to 90)`).to.be.within(-90, 90);
    expect(long, `Airport longitude ${long} is out of range (-180 to 180)`).to.be.within(-180, 180);
    expect(lat).to.not.equal(0, "Latitude is exactly 0.0 - possible missing data");
    expect(long).to.not.equal(0, "Longitude is exactly 0.0 - possible missing data");
  });
  
  // Test 10: Validate altitude
  test("[HP] - Range Validation - should have realistic altitude value - " + endpoint, () => {
    const altitude = Number(airportData.altitude);
    expect(altitude, `Altitude ${altitude} is out of realistic range (-1500 to 30000 feet)`).to.be.within(-1500, 30000);
  });
  
  // Test 11: Validate timezone format
  test("[HP] - Format Validation - should have valid timezone format - " + endpoint, () => {
    expect(timezone, `Timezone ${timezone} does not match expected format (letters, underscores, slashes)`).to.match(/^[A-Za-z_\/]+$/);
  });
  
  // Test 12: Validate note message
  test("[HP] - Message Validation - note should match expected value - " + endpoint, () => {
    const expectedNote = "My local airport";
    if (note !== null) {
      expect(note, `Note "${note}" doesn't match expected "${expectedNote}"`).to.equal(expectedNote);
    }
  });
}

settings {
  encodeUrl: true
  timeout: 0
}
