meta {
  name: [HP] GET /airports/distance
  type: http
  seq: 3
}

post {
  url: {{baseUrl}}/airports/distance
  body: formUrlEncoded
  auth: inherit
}

body:json {
  {
  "from"="KIX"
  "to"="NRT"
  }
}

body:form-urlencoded {
  from: VIE
  to: LHR
}

tests {
  // Global configuration
  const scenario = 'Get airport distance';
  const endpoint = '/airports/distance';
  
  // Constant variables
  const MAX_RESPONSE_TIME_MS = Number(bru.getVar("MAX_RESPONSE_TIME_STANDARD")) || 2000;
  const STATUS_OK = Number(bru.getVar("STATUS_OK")) || 200;
  
  // Earth constants for validation
  const MAX_EARTH_DISTANCE_KM = 20038; 
  const KM_TO_MILES = 0.621371;
  const KM_TO_NAUTICAL = 0.539957;
  const TOLERANCE_PCT = 0.01; 
  
  const IATA_PATTERN = /^[A-Z]{3}$/;
  
  const body = res.getBody();
  const distanceData = body ? body.data : null;
  const attributes = distanceData ? distanceData.attributes : null;
  
  // Required keys
  const requiredDistanceKeys = ['id', 'type', 'attributes'];
  const requiredAttributeKeys = ['from_airport', 'to_airport', 'kilometers', 'miles', 'nautical_miles'];
  const requiredAirportKeys = ['id', 'name', 'city', 'country', 'iata', 'icao', 'latitude', 'longitude', 'altitude', 'timezone'];
  
  // Helper function
  function validateAirportIATA(airport, airportLabel) {
    expect(airport.iata, `${airportLabel}: IATA code "${airport.iata}" invalid`).to.match(IATA_PATTERN);
  }
  
  // Test 1: Status code
  test(`[HP] - ${scenario} - Status Code - should return ${STATUS_OK}`, () => {
    expect(res.getStatus()).to.equal(STATUS_OK);
  });
  
  // Test 2: Performance
  test(`[HP] - ${scenario} - Performance - response within limits`, () => {
    expect(res.getResponseTime()).to.be.below(MAX_RESPONSE_TIME_MS);
  });
  
  // Test 3: Content-Type
  test(`[HP] - ${scenario} - Headers - should return JSON`, () => {
    expect(res.getHeader('content-type')).to.include('application/json');
  });
  
  // Test 4: Structure validation
  test(`[HP] - ${scenario} - Response Structure - distance data validation`, () => {
    expect(distanceData, "Data object missing").to.be.an('object');
    expect(Object.keys(distanceData).length).to.be.greaterThan(0);
    expect(distanceData.type).to.equal('airport_distance');
  });
  
  // Test 5: Schema Validation (Keys)
  test(`[HP] - ${scenario} - Schema Validation - required keys check`, () => {
    requiredDistanceKeys.forEach(key => expect(distanceData).to.have.property(key));
    requiredAttributeKeys.forEach(key => expect(attributes).to.have.property(key));
    
    requiredAirportKeys.forEach(key => {
      expect(attributes.from_airport).to.have.property(key);
      expect(attributes.to_airport).to.have.property(key);
    });
  });
  
  // Test 6: Data types
  test(`[HP] - ${scenario} - Data Types - numbers and objects validation`, () => {
    expect(attributes.kilometers).to.be.a('number');
    expect(attributes.miles).to.be.a('number');
    expect(attributes.from_airport).to.be.an('object');
  });
  
  // Test 7: Range Validation (Distance)
  test(`[HP] - ${scenario} - Range Validation - realistic distance checks`, () => {
    expect(attributes.kilometers).to.be.within(0.1, MAX_EARTH_DISTANCE_KM);
    expect(attributes.miles).to.be.greaterThan(0);
  });
  
  // Test 8: Data Accuracy 
  test(`[HP] - ${scenario} - Data Accuracy - conversion check`, () => {
    const expectedMiles = attributes.kilometers * KM_TO_MILES;
    const diff = Math.abs(attributes.miles - expectedMiles);
    const pctOff = diff / expectedMiles;
    
    expect(pctOff, `Miles conversion deviation too high: ${pctOff.toFixed(4)}`).to.be.below(TOLERANCE_PCT);
  });
  
  // Test 9: Data Integrity (Source vs Destination)
  test(`[HP] - ${scenario} - Data Integrity - source and destination must differ`, () => {
    expect(attributes.from_airport.id).to.not.equal(attributes.to_airport.id);
  });
  
  // Test 10: Formats & GPS
  test(`[HP] - ${scenario} - Format & GPS - validation of both airports`, () => {
    const airports = [
      { label: 'From', data: attributes.from_airport },
      { label: 'To', data: attributes.to_airport }
    ];
  
    airports.forEach(a => {
      validateAirportIATA(a.data, a.label);
      const lat = parseFloat(a.data.latitude);
      const lon = parseFloat(a.data.longitude);
      expect(lat).to.be.within(-90, 90);
      expect(lon).to.be.within(-180, 180);
      expect(a.data.name.trim()).to.not.be.empty;
    });
  });
}

settings {
  encodeUrl: true
  timeout: 0
}
