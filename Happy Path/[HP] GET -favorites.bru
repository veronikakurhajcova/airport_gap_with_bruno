meta {
  name: [HP] GET /favorites
  type: http
  seq: 4
}

get {
  url: {{baseUrl}}/favorites
  body: json
  auth: none
}

headers {
  Authorization: Bearer {{airportgap_token}}
}

script:post-response {
  const body = res.getBody();
  bru.setEnvVar("fid", body.data[0].id);
  bru.setEnvVar("airId", body.data[0].attributes.id);
  bru.setEnvVar("expectedNote", body.data[0].attributes.note);
  
  bru.setEnvVar("expectedId", body.data[0].attributes.airport.id);
  bru.setEnvVar("expectedName", body.data[0].attributes.airport.name);
  bru.setEnvVar("expectedCity", body.data[0].attributes.airport.city);
  bru.setEnvVar("expectedCountry", body.data[0].attributes.airport.country);
  bru.setEnvVar("expectedIata", body.data[0].attributes.airport.iata);
  bru.setEnvVar("expectedIcao", body.data[0].attributes.airport.icao);
  bru.setEnvVar("expectedLat", body.data[0].attributes.airport.latitude);
  bru.setEnvVar("expectedLong", body.data[0].attributes.airport.longitude);
  bru.setEnvVar("expectedAltitde", body.data[0].attributes.airport.altitude);
  bru.setEnvVar("expectedTimezone", body.data[0].attributes.airport.timezone);
  
  
  
  
}

tests {
  const body = res.getBody();
  const data = body.data;
  const firstItem = data[0];
  const links = body.links;
  const attributes = data[0].attributes;
  const airportData = attributes.airport;
  const timezone = airportData.timezone;
  const endpoint = '/favorites';
  
  // Configuration
  const MAX_RESPONSE_TIME_MS = 2000;
  
  // Validation schema
  const schema = {
    type: "object",
    required: ["data", "links"],
    properties: {
      data: {
        type: "array",
        items: { 
          type: "object",
          required: ["id", "type", "attributes"],
          properties: {
            id: { type: "string" },
            type: { type: "string" },
            attributes: {
              type: "object",
              required: ["airport", "note"],
              properties: {
                airport: {
                  type: "object",
                  required: ["id", "name", "city", "country", "iata", "icao", "latitude", "longitude", "altitude", "timezone"],
                  properties: {
                    id: { type: "number" },
                    name: { type: "string" },
                    city: { type: "string" },
                    country: { type: "string" },
                    iata: { type: "string" },
                    icao: { type: ["string", "null"] }, 
                    latitude: { type: "string" },
                    longitude: { type: "string" },
                    altitude: { type: "number" },
                    timezone: { type: "string" }
                  }
                },
                note: { type: ["string", "null"] } 
              }
            }
          }
        }
      },
      links: {
        type: "object",
        required: ["first", "self", "last", "prev", "next"],
        properties: {
          first: { type: "string" },
          self: { type: "string" },
          last: { type: "string" },
          prev: { type: "string" },
          next: { type: "string" }
        }
      }
    }
  };
  
  // Helper function
  function validateAirportIATAFormat(airport, airportName) {
    expect(airport.iata, `${airportName} IATA code "${airport.iata}" does not match format (3 uppercase letters)`).to.match(/^[A-Z]{3}$/);
  }
  
  // Test 1: Status code
  test("[HP] - Status Code - should return 200 - " + endpoint, () => {
    expect(res.getStatus(), `Expected status code 200 but got ${res.getStatus()}`).to.equal(200);
  });
  
  // Test 2: Response time
  test("[HP] - Performance - should respond within acceptable time - " + endpoint, () => {
    expect(res.getResponseTime(), `Response time ${res.getResponseTime()}ms exceeded ${MAX_RESPONSE_TIME_MS}ms`).to.be.below(MAX_RESPONSE_TIME_MS);
  });
  
  // Test 3: Content-Type
  test("[HP] - Headers - should return JSON content type - " + endpoint, () => {
    const contentType = res.getHeader('content-type');
    expect(contentType, `Expected Content-Type to include "application/json" but got "${contentType}"`).to.include('application/json');
  });
  
  // Test 4: Base structure
  test("[HP] - Response Structure - should return data object - " + endpoint, () => {
    expect(body, `Response body is missing "data" property`).to.have.property('data');
    expect(data, `Property "data" should be array but got ${typeof data}`).to.be.an('array');
  });
  
  // Test 5: Attributes object not empty
  test("[HP] - Data Validation - data array should not be empty - " + endpoint, () => {
    expect(data.length, `Data array is empty`).to.be.greaterThan(0);
  });
  
  // Test 6: Schema Validation & Data Type Validation
  test("[HP] - Contract Testing - Comprehensive Schema Validation - " + endpoint, () => {
    // 1. Validate (data, links)
    schema.required.forEach(key => {
      expect(body, `Root missing: ${key}`).to.have.property(key);
    });
  
    // 2. Validate data
    const itemSchema = schema.properties.data.items;
    itemSchema.required.forEach(key => {
      expect(firstItem, `Item missing: ${key}`).to.have.property(key);
      expect(firstItem[key], `Type mismatch for ${key}`).to.be.a(itemSchema.properties[key].type);
    });
  
    // 3. Validate attributes
    const attrSchema = itemSchema.properties.attributes;
    attrSchema.required.forEach(key => {
      expect(attributes, `Attributes missing: ${key}`).to.have.property(key);
    });
  
    // 4. Validate airports 
    const airSchema = attrSchema.properties.airport;
    airSchema.required.forEach(key => {
      expect(airportData, `Airport object missing: ${key}`).to.have.property(key);
      
      // Validate data types
      const expectedType = airSchema.properties[key].type;
      if (Array.isArray(expectedType)) {
        const actualType = airportData[key] === null ? "null" : typeof airportData[key];
        expect(expectedType, `Type mismatch for ${key}: expected one of [${expectedType}] but got ${actualType}`).to.include(actualType);
      } else {
        expect(airportData[key], `Type mismatch for ${key}: expected ${expectedType}`).to.be.a(expectedType);
      }
    });
  });
  
  // Test 7: Validation - (IATA format)
  test("[HP] - Data Integrity - IATA code format - " + endpoint, () => {
    validateAirportIATAFormat(airportData, "Favorite Airport");
  });
  
  // Test 8: GPS coordinates validation
  test("[HP] - Range Validation - airports should have valid GPS coordinates - " + endpoint, () => {
    const lat= Number(airportData.latitude);
    const long = Number(airportData.longitude);
    expect(lat, `airport latitude ${lat} is out of range (-90 to 90)`).to.be.within(-90, 90);
    expect(long, `airport longitude ${long} is out of range (-180 to 180)`).to.be.within(-180, 180);
    expect(lat).to.not.equal(0, "Latitude is exactly 0.0 - possible missing data");
    expect(long).to.not.equal(0, "Longitude is exactly 0.0 - possible missing data");
  });
  
  // Test 9: Validate altitude
  test("[HP] - Range Validation - should have realistic altitude value - " + endpoint, () =>  {
    const altitude= Number(airportData.altitude);
    expect(altitude, `Altitude ${altitude} is out of realistic range (-1500 to 30000 feet)`).to.be.within(-1500, 30000);
  });
  
  // Test 10: Validate timezone format
  test("[HP] - Format Validation - should have valid timezone format - " + endpoint, () =>  {
    expect(timezone, `Timezone ${timezone} does not match expected format (letters, underscores, slashes)`).to.match(/^[A-Za-z_\/]+$/);
  });
  
  // Test 11: Validate links
  test("[HP] - Response Structure - should return links object - " + endpoint, () => {
    expect(body, `Body is missing "links" property`).to.have.property('links');
    expect(links, `Property "links" should be object but got ${typeof links}`).to.be.an('object');
    expect(Object.keys(links).length, `Links object is empty`).to.be.greaterThan(0);
  });
  
  // Test 13 - Links object not empty
  test("[HP] - Links Validation - should include https://airportgap.com/api/airports - " + endpoint, () => {
    const linksItems = ["first", "self", "last", "prev", "next"];
    const linksUrl = "https://airportgap.com/api/airports";
    
    linksItems.forEach(link => {
      expect(links[link], `Links "${link}" does not contain ${linksUrl}`).to.include(linksUrl);
    });
  });
  
  
  
}

settings {
  encodeUrl: true
  timeout: 0
}
