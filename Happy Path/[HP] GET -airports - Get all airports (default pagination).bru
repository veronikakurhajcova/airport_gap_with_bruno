meta {
  name: [HP] GET /airports - Get all airports (default pagination)
  type: http
  seq: 1
}

get {
  url: {{baseUrl}}/airports
  body: none
  auth: inherit
}

tests {
  // Global configuration
  const scenario = 'Get all airports';
  const endpoint = '/airports';
  
  // Constant variables
  const MAX_RESPONSE_TIME_MS = Number(bru.getVar("MAX_RESPONSE_TIME_STANDARD")) || 2000;
  const STATUS_OK = Number(bru.getVar("STATUS_OK")) || 200;
  const DEFAULT_PAGE_LIMIT = Number(bru.getVar("DEFAULT_PAGE_LIMIT")) || 30;
  
  const IATA_PATTERN = /^[A-Z]{3}$/;
  const ICAO_PATTERN = /^[A-Z]{4}$/;
  const TIMEZONE_PATTERN = /^[A-Za-z_\/]+$/;
  
  const body = res.getBody();
  const data = body ? body.data : null;
  const firstAirport = data ? data[0] : null;
  const attributes = firstAirport ? firstAirport.attributes : null;
  
  // Required keys for validation
  const requiredAirportKeys = ['id', 'type', 'attributes'];
  const requiredAttributeKeys = ['name', 'city', 'country', 'iata', 'icao', 'latitude', 'longitude', 'altitude', 'timezone'];
  
  // Test 1: Status code
  test(`[HP] - ${scenario} - Status Code - should return ${STATUS_OK}`, () => {
    expect(res.getStatus()).to.equal(STATUS_OK);
  });
  
  // Test 2: Performance
  test(`[HP] - ${scenario} - Performance - response within limits`, () => {
    expect(res.getResponseTime()).to.be.below(MAX_RESPONSE_TIME_MS);
  });
  
  // Test 3: Content-Type
  test(`[HP] - ${scenario} - Headers - should return JSON`, () => {
    expect(res.getHeader('content-type')).to.include('application/json');
  });
  
  // Test 4: Structure & Non-empty data
  test(`[HP] - ${scenario} - Response Structure - data array validation`, () => {
    expect(data, "Response data should be an array").to.be.an('array');
    expect(data.length, "Data array should not be empty").to.be.greaterThan(0);
  });
  
  // Test 5: Schema Validation (Keys)
  test(`[HP] - ${scenario} - Schema Validation - required keys check`, () => {
    requiredAirportKeys.forEach(key => {
      expect(firstAirport, `Missing airport key: ${key}`).to.have.property(key);
    });
    requiredAttributeKeys.forEach(key => {
      expect(attributes, `Missing attribute key: ${key}`).to.have.property(key);
    });
  });
  
  // Test 6: Data Types Validation
  test(`[HP] - ${scenario} - Data Types - attributes types check`, () => {
    expect(firstAirport.id).to.be.a('string');
    expect(attributes.name).to.be.a('string');
    expect(attributes.altitude).to.be.a('number');
  
    if (attributes.icao !== null) {
      expect(attributes.icao).to.be.a('string');
    }
  });
  
  // Test 7: Format Validation (Regex)
  test(`[HP] - ${scenario} - Format Validation - IATA, ICAO, Timezone`, () => {
    expect(attributes.iata).to.match(IATA_PATTERN);
    if (attributes.icao) {
      expect(attributes.icao).to.match(ICAO_PATTERN);
    }
    expect(attributes.timezone).to.match(TIMEZONE_PATTERN);
  });
  
  // Test 8: Range Validation (GPS & Altitude)
  test(`[HP] - ${scenario} - Range Validation - GPS and Altitude`, () => {
    const lat = parseFloat(attributes.latitude);
    const lon = parseFloat(attributes.longitude);
    
    expect(lat).to.be.within(-90, 90);
    expect(lon).to.be.within(-180, 180);
    expect(attributes.altitude).to.be.within(-1500, 30000);
  });
  
  // Test 9: Data Consistency
  test(`[HP] - ${scenario} - Data Consistency - all records structure`, () => {
    data.forEach((airport, index) => {
      expect(airport.type, `Index ${index} has wrong type`).to.equal('airport');
      expect(airport.id, `Index ${index} has empty ID`).to.not.be.empty;
    });
  });
  
  // Test 10: ID Uniqueness
  test(`[HP] - ${scenario} - Data Integrity - unique airport IDs`, () => {
    const ids = data.map(a => a.id);
    const uniqueIds = [...new Set(ids)];
    expect(ids.length, "Duplicate IDs found in response").to.equal(uniqueIds.length);
  });
  
  // Test 11: Pagination
  test(`[HP] - ${scenario} - Pagination - limit and links`, () => {
    expect(data.length).to.be.at.most(DEFAULT_PAGE_LIMIT);
    if (body.links) {
      expect(body.links).to.have.property('self');
    }
  });
}

settings {
  encodeUrl: true
  timeout: 0
}
