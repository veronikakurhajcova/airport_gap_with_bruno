meta {
  name: 05_[HP] DELETE /favorites/:id
  type: http
  seq: 4
}

delete {
  url: {{baseUrl}}/favorites/{{fid}}
  body: none
  auth: inherit
}

headers {
  Authorization: Bearer token={{airportgap_token}}
}

tests {
  // Global configuration
  const scenario = 'Delete favorite airport';
  const endpoint = '/favorites/:id';
  
  // Constant variables
  const MAX_RESPONSE_TIME_MS = Number(bru.getVar("MAX_RESPONSE_TIME_STANDARD")) || 2000;
  const STATUS_NO_CONTENT = 204; // 
  
  // Test 1: Status code
  test(`[HP] - ${scenario} - Status Code - should return ${STATUS_NO_CONTENT} - ${endpoint}`, () => {
    expect(res.getStatus(), `Expected status code ${STATUS_NO_CONTENT} but got ${res.getStatus()}`).to.equal(STATUS_NO_CONTENT);
  });
  
  // Test 2: Performance
  test(`[HP] - ${scenario} - Performance - should respond within acceptable time - ${endpoint}`, () => {
    expect(res.getResponseTime(), `Response time ${res.getResponseTime()}ms exceeded ${MAX_RESPONSE_TIME_MS}ms`).to.be.below(MAX_RESPONSE_TIME_MS);
  });
  
  // Test 3: Empty body validation
  test(`[HP] - ${scenario} - Response Structure - Body should be empty for 204 - ${endpoint}`, () => {
    const body = res.getBody();
    
    if (body && typeof body === 'object') {
      expect(Object.keys(body).length, `Response body should be empty but contains keys: ${Object.keys(body)}`).to.equal(0);
    } else {
      expect(body, `Response body should be empty but contains data`).to.not.be.ok;
    }
  });
  
  bru.setNextRequest(null);
}

settings {
  encodeUrl: true
  timeout: 0
}
