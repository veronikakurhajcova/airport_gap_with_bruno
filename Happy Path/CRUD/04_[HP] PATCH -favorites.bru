meta {
  name: 04_[HP] PATCH /favorites
  type: http
  seq: 3
}

patch {
  url: {{baseUrl}}/favorites/{{fid}}
  body: json
  auth: inherit
}

headers {
  Authorization: Bearer token={{airportgap_token}}
}

body:json {
  {
    "note":"Updated note"
  }
}

tests {
  // Global configuration
  const scenario = 'Patch favorite airport';
  const endpoint = '/airport/favorites/:id';
  
  // Constant variables
  const BASE_URL = bru.getVar("BASE_URL") || "https://airportgap.com/api";
  const MAX_RESPONSE_TIME_MS = Number(bru.getVar("MAX_RESPONSE_TIME_STANDARD")) || 1000;
  const STATUS_OK = Number(bru.getVar("STATUS_OK")) || 200;
  
  const IATA_PATTERN = /^[A-Z]{3}$/;
  const TIMEZONE_PATTERN = /^[A-Za-z_\/]+$/;
  
  const MIN_LATITUDE = Number(bru.getVar("MIN_LATITUDE")) || -90;
  const MAX_LATITUDE = Number(bru.getVar("MAX_LATITUDE")) || 90;
  const MIN_LONGITUDE = Number(bru.getVar("MIN_LONGITUDE")) || -180;
  const MAX_LONGITUDE = Number(bru.getVar("MAX_LONGITUDE")) || 180;
  const MIN_ALTITUDE = Number(bru.getVar("MIN_ALTITUDE")) || -1500;
  const MAX_ALTITUDE = Number(bru.getVar("MAX_ALTITUDE")) || 30000;
  
  const body = res.getBody();
  const data = body ? body.data : null;
  const attributes = data ? data.attributes : null;
  const airportData = attributes ? attributes.airport : null;
  const note = attributes ? attributes.note : null;
  const timezone = airportData ? airportData.timezone : null;
  
  // Validation schema
  const schema = {
    type: "object",
    required: ["id", "type", "attributes"],
    properties: {
      id: { type: "string" },
      type: { type: "string" }, 
      attributes: {
        type: "object",
        required: ["airport", "note"],
        properties: {
          airport: {
            type: "object",
            required: ["id", "name", "city", "country", "iata", "icao", "latitude", "longitude", "altitude", "timezone"],
            properties: {
              id: { type: "number" },
              name: { type: "string" },
              city: { type: "string" },
              country: { type: "string" },
              iata: { type: "string" },
              icao: { type: "string" },
              latitude: { type: "string" },
              longitude: { type: "string" },
              altitude: { type: "number" },
              timezone: { type: "string" }
            }
          },
          note: { type: "string" }
        }
      }
    }
  };
  
  // Helper function
  function validateAirportIATAFormat(iata, airportName) {
    expect(iata, `${airportName}: IATA code "${iata}" does not match format`).to.match(IATA_PATTERN);
  }
  
  // Test 1: Status code
  test(`[HP] - ${scenario} - Status Code - should return ${STATUS_OK}`, () => {
    expect(res.getStatus()).to.equal(STATUS_OK);
  });
  
  // Test 2: Response time
  test(`[HP] - ${scenario} - Performance - should respond within limits`, () => {
    expect(res.getResponseTime()).to.be.below(MAX_RESPONSE_TIME_MS);
  });
  
  // Test 3: Content-Type
  test(`[HP] - ${scenario} - Headers - should return JSON content type`, () => {
    expect(res.getHeader('content-type')).to.include('application/json');
  });
  
  // Test 4 & 5: Structure & Data Validation
  test(`[HP] - ${scenario} - Response Structure - should return valid data object`, () => {
    expect(data, "Response data is missing or not an object").to.be.an('object').and.not.be.an('array');
    expect(Object.keys(data).length).to.be.greaterThan(0);
  });
  
  // Test 6: ID validation
  test(`[HP] - ${scenario} - ID Validation - favorite ID should match request`, () => {
    const requestedId = bru.getEnvVar("fid");
    expect(data.id).to.equal(String(requestedId));
  });
  
  // Test 7: Schema Validation
  test(`[HP] - ${scenario} - Contract Testing - Schema Validation`, () => {
    // 1. Root properties
    schema.required.forEach(key => {
      expect(data).to.have.property(key);
    });
  
    // 2. Attributes properties
    const attrSchema = schema.properties.attributes;
    attrSchema.required.forEach(key => {
      expect(attributes).to.have.property(key);
    });
  
    // 3. Airport properties
    const airSchema = attrSchema.properties.airport;
    airSchema.required.forEach(key => {
      expect(airportData).to.have.property(key);
      expect(airportData[key]).to.be.a(airSchema.properties[key].type);
    });
  });
  
  // Test 8: IATA format validation
  test(`[HP] - ${scenario} - Data Integrity - IATA code format`, () => {
    validateAirportIATAFormat(airportData.iata, "Favorite Airport");
  });
  
  // Test 9 & 10: Range Validation (GPS & Altitude)
  test(`[HP] - ${scenario} - Range Validation - GPS and Altitude`, () => {
    const lat = Number(airportData.latitude);
    const long = Number(airportData.longitude);
    const alt = Number(airportData.altitude);
  
    expect(lat).to.be.within(MIN_LATITUDE, MAX_LATITUDE);
    expect(long).to.be.within(MIN_LONGITUDE, MAX_LONGITUDE);
    expect(alt).to.be.within(MIN_ALTITUDE, MAX_ALTITUDE);
    expect(lat !== 0 || long !== 0, "GPS coordinates are [0,0]").to.be.true;
  });
  
  // Test 11: Timezone format
  test(`[HP] - ${scenario} - Format Validation - Timezone`, () => {
    expect(timezone).to.match(TIMEZONE_PATTERN);
  });
  
  // Test 12: Note validation
  test(`[HP] - ${scenario} - Message Validation - note should be updated`, () => {
    const expectedNote = 'Updated note';
    expect(note).to.equal(expectedNote);
  });
  
  // Test 13: Data integrity (comparison with environment)
  test(`[HP] - ${scenario} - Data integrity - other values unchanged`, () => {
    expect(airportData.id).to.equal(Number(bru.getEnvVar("expectedId")));
    expect(airportData.name).to.equal(bru.getEnvVar("expectedName"));
    
    const tolerance = 0.00003;
    expect(Number(airportData.latitude)).to.be.closeTo(Number(bru.getEnvVar("expectedLat")), tolerance);
    expect(Number(airportData.longitude)).to.be.closeTo(Number(bru.getEnvVar("expectedLong")), tolerance);
  });
  
  bru.setNextRequest("05_[HP] /favorites/:id");
}

settings {
  encodeUrl: true
  timeout: 0
}
