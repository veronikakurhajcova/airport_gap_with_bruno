meta {
  name: 03_[HP] GET /favorites
  type: http
  seq: 1
}

get {
  url: {{baseUrl}}/favorites
  body: json
  auth: none
}

headers {
  Authorization: Bearer {{airportgap_token}}
}

script:post-response {
  const body = res.getBody();
  bru.setEnvVar("fid", body.data[0].id);
  bru.setEnvVar("airId", body.data[0].attributes.id);
  bru.setEnvVar("expectedNote", body.data[0].attributes.note);
  
  bru.setEnvVar("expectedId", body.data[0].attributes.airport.id);
  bru.setEnvVar("expectedName", body.data[0].attributes.airport.name);
  bru.setEnvVar("expectedCity", body.data[0].attributes.airport.city);
  bru.setEnvVar("expectedCountry", body.data[0].attributes.airport.country);
  bru.setEnvVar("expectedIata", body.data[0].attributes.airport.iata);
  bru.setEnvVar("expectedIcao", body.data[0].attributes.airport.icao);
  bru.setEnvVar("expectedLat", body.data[0].attributes.airport.latitude);
  bru.setEnvVar("expectedLong", body.data[0].attributes.airport.longitude);
  bru.setEnvVar("expectedAltitude", body.data[0].attributes.airport.altitude);
  bru.setEnvVar("expectedTimezone", body.data[0].attributes.airport.timezone);
  
  
  
  
}

tests {
  // Configuration
  const scenario = 'Get all favorites airports';
  const endpoint = '/favorites';
  
  const BASE_URL = bru.getVar("BASE_URL") || "https://airportgap.com/api";
  const MAX_RESPONSE_TIME_MS = Number(bru.getVar("MAX_RESPONSE_TIME_STANDARD"));
  const STATUS_OK = Number(bru.getVar("STATUS_OK")) || 200;
  const IATA_PATTERN = /^[A-Z]{3}$/;
  const TIMEZONE_PATTERN = /^[A-Za-z_\/]+$/;
  
  const MIN_LATITUDE = Number(bru.getVar("MIN_LATITUDE")) || -90;
  const MAX_LATITUDE = Number(bru.getVar("MAX_LATITUDE")) || 90;
  const MIN_LONGITUDE = Number(bru.getVar("MIN_LONGITUDE")) || -180;
  const MAX_LONGITUDE = Number(bru.getVar("MAX_LONGITUDE")) || 180;
  const MIN_ALTITUDE = Number(bru.getVar("MIN_ALTITUDE")) || -1500;
  const MAX_ALTITUDE = Number(bru.getVar("MAX_ALTITUDE")) || 30000;
  
  const DEFAULT_PAGE_LIMIT = Number(bru.getVar("DEFAULT_PAGE_LIMIT")) || 30;
  
  const body = res.getBody();
  const data = body.data;
  const firstItem = data ? data[0] : null;
  const links = body.links;
  const attributes = firstItem ? firstItem.attributes : null;
  const airportData = attributes ? attributes.airport : null;
  const timezone = airportData ? airportData.timezone : null;
  
  // Validation schema
  const schema = {
    type: "object",
    required: ["data", "links"],
    properties: {
      data: {
        type: "array",
        items: { 
          type: "object",
          required: ["id", "type", "attributes"],
          properties: {
            id: { type: "string" },
            type: { type: "string" },
            attributes: {
              type: "object",
              required: ["airport", "note"],
              properties: {
                airport: {
                  type: "object",
                  required: ["id", "name", "city", "country", "iata", "icao", "latitude", "longitude", "altitude", "timezone"],
                  properties: {
                    id: { type: "number" },
                    name: { type: "string" },
                    city: { type: "string" },
                    country: { type: "string" },
                    iata: { type: "string" },
                    icao: { type: ["string", "null"] }, 
                    latitude: { type: "string" },
                    longitude: { type: "string" },
                    altitude: { type: "number" },
                    timezone: { type: "string" }
                  }
                },
                note: { type: ["string", "null"] } 
              }
            }
          }
        }
      },
      links: {
        type: "object",
        required: ["first", "self", "last", "prev", "next"],
        properties: {
          first: { type: "string" },
          self: { type: "string" },
          last: { type: "string" },
          prev: { type: "string" },
          next: { type: "string" }
        }
      }
    }
  };
  
  // Test 1: Status code
  test(`[HP] - ${scenario} - Status Code - should return ${STATUS_OK} - ${endpoint}`, () => {
    expect(res.getStatus(), `Expected status code ${STATUS_OK} but got ${res.getStatus()}`).to.equal(STATUS_OK);
  });
  
  // Test 2: Response time
  test(`[HP] - ${scenario} - Performance - should respond within acceptable time - ${endpoint}`, () => {
    expect(res.getResponseTime(), `Response time ${res.getResponseTime()} ms exceeded ${MAX_RESPONSE_TIME_MS} ms`).to.be.below(MAX_RESPONSE_TIME_MS);
  });
  
  // Test 3: Content-Type
  test(`[HP] - ${scenario} - Headers - should return JSON content type - ${endpoint}`, () => {
    const contentType = res.getHeader('content-type');
    expect(contentType, `Expected Content-Type to include "application/json" but got "${contentType}"`).to.include('application/json');
  });
  
  // Test 4: Base structure
  test(`[HP] - ${scenario} - Response Structure - should return data object - ${endpoint}`, () => {
    expect(body, `Response body is missing "data" property`).to.have.property('data');
    expect(data, `Property "data" should be array but got ${typeof data}`).to.be.an('array');
  });
  
  // Test 5: Attributes object not empty
  test(`[HP] - ${scenario} - Data Validation - data array should not be empty - ${endpoint}`, () => {
    expect(data.length, `Data array is empty`).to.be.greaterThan(0);
  });
  
  // Test 6: Schema Validation & Data Type Validation
  test(`[HP] - ${scenario} - Contract Testing - Comprehensive Schema Validation - ${endpoint}`, () => {
    schema.required.forEach(key => {
      expect(body, `Root missing: ${key}`).to.have.property(key);
    });
  
    const itemSchema = schema.properties.data.items;
    itemSchema.required.forEach(key => {
      expect(firstItem, `Item missing: ${key}`).to.have.property(key);
      expect(firstItem[key], `Type mismatch for ${key}`).to.be.a(itemSchema.properties[key].type);
    });
  
    const attrSchema = itemSchema.properties.attributes;
    attrSchema.required.forEach(key => {
      expect(attributes, `Attributes missing: ${key}`).to.have.property(key);
    });
  
    const airSchema = attrSchema.properties.airport;
    airSchema.required.forEach(key => {
      expect(airportData, `Airport object missing: ${key}`).to.have.property(key);
      
      const expectedType = airSchema.properties[key].type;
      if (Array.isArray(expectedType)) {
        const actualType = airportData[key] === null ? "null" : typeof airportData[key];
        expect(expectedType, `Type mismatch for ${key}: expected one of [${expectedType}] but got ${actualType}`).to.include(actualType);
      } else {
        expect(airportData[key], `Type mismatch for ${key}: expected ${expectedType}`).to.be.a(expectedType);
      }
    });
  });
  
  // Test 7 : Data validation
  test(`[HP] - ${scenario} - Data Integrity - All airports should have valid IATA and GPS - ${endpoint}`, () => {
    data.forEach((item, index) => {
      const airport = item.attributes.airport;
      const name = airport.name || `Airport at index ${index}`;
      
      // Validation IATA
      expect(airport.iata, `${name}: IATA code "${airport.iata}" is invalid`).to.match(IATA_PATTERN);
      
      // Validation GPS
      const lat = Number(airport.latitude);
      const long = Number(airport.longitude);
      
      expect(lat, `${name}: latitude ${lat} out of range`).to.be.within(MIN_LATITUDE, MAX_LATITUDE);
      expect(long, `${name}: longitude ${long} out of range`).to.be.within(MIN_LONGITUDE, MAX_LONGITUDE);
      
      expect(lat !== 0 || long !== 0, `${name}: GPS is [0,0] - possible missing data`).to.be.true;
    });
  });
  
  // Test 8: Validate altitude
  test(`[HP] - ${scenario} - Range Validation - should have realistic altitude value - ${endpoint}`, () => {
    data.forEach((item, index) => {
      const currentAltitude = Number(item.attributes.airport.altitude);
      const name = item.attributes.airport.name || `Airport #${index}`;  
      expect(currentAltitude, `${name}: Altitude ${currentAltitude} is out of range`).to.be.within(MIN_ALTITUDE, MAX_ALTITUDE);
    });
  });
  
  // Test 9: Validate timezone format
  test(`[HP] - ${scenario} - Format Validation - should have valid timezone format - ${endpoint}`, () => {
    data.forEach((item, index) => {
      const currentTimezone = item.attributes.airport.timezone;
      const name = item.attributes.airport.name || `Airport #${index}`;  
      expect(currentTimezone, `${name}: Timezone ${currentTimezone} invalid format`).to.match(TIMEZONE_PATTERN);
    });
  });
  
  // Test 10: Validate links
  test(`[HP] - ${scenario} - Response Structure - should return links object - ${endpoint}`, () => {
    expect(body, `Body is missing "links" property`).to.have.property('links');
    expect(links, `Property "links" should be object but got ${typeof links}`).to.be.an('object');
    expect(Object.keys(links).length, `Links object is empty`).to.be.greaterThan(0);
  });
  
  // Test 11: Links content validation
  test(`[HP] - ${scenario} - Links Validation - should include official API URL - ${endpoint}`, () => {
    const linksItems = ["first", "self", "last", "prev", "next"];
    
    linksItems.forEach(link => {
      expect(links[link]).to.match(/\/(favorites|airports)/);
    });
  });
  
  // Test 13: Pagination limit
  test(`[Pagination] - ${scenario} - Limit Validation - Should return no more than ${DEFAULT_PAGE_LIMIT} items - ${endpoint}`, () => {
      expect(data.length).to.be.at.most(DEFAULT_PAGE_LIMIT);
  });
  
  bru.setNextRequest("04_[HP] PATCH /favorites");
}

settings {
  encodeUrl: true
  timeout: 0
}
